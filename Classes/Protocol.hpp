// Generated by the ProtoType compiler.  DO NOT EDIT!
// File:      Protocol.hpp
// Create on: Fri Jul 25 23:48:21 2014
//

#ifndef __PROTOCOL_HPP__
#define __PROTOCOL_HPP__

#include <stdint.h>
#include <string.h>
#include <vector>

namespace Protocol
{

class CType_stPack
{
public:
    CType_stPack();
    ~CType_stPack();

    uint32_t& dwMagic();
    uint16_t& wVersion();
    uint16_t& wCommand();
    const uint16_t& wDataSize() const;
    size_t GetNumberOf_acData() const;
    uint8_t& acData(size_t uIndex);
    uint8_t* acData();
    void Assign_acData(const uint8_t acData[], size_t uNumberOfElements);
    uint8_t& Add_cData();

    size_t SerializeToArray(void* pBuf, size_t uBufSize) const;
    size_t ParseFromArray(const void* pBuf, size_t uBufSize);

public:
    uint32_t m_dwMagic;
    uint16_t m_wVersion;
    uint16_t m_wCommand;
    uint16_t m_wDataSize;
    std::vector<uint8_t> m_acData;
};

class CType_stCmdRoomBroadCast
{
public:
    CType_stCmdRoomBroadCast();
    ~CType_stCmdRoomBroadCast();

    uint16_t& wMapIndex();
    uint16_t& wStageIndex();
    uint16_t& wLevel();

    size_t SerializeToArray(void* pBuf, size_t uBufSize) const;
    size_t ParseFromArray(const void* pBuf, size_t uBufSize);

public:
    uint16_t m_wMapIndex;
    uint16_t m_wStageIndex;
    uint16_t m_wLevel;
};

};



///////////////// - Inline Implementation - /////////////////

namespace Protocol
{

#ifndef ___constant_swab64
#define ___constant_swab64(x) \
    ((uint64_t)( \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56) ))
#endif // ___constant_swab64

inline uint64_t htonl64(uint64_t host)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return ___constant_swab64(host);
#else
    return host;
#endif
}

inline uint64_t ntohl64(uint64_t net)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return ___constant_swab64(net);
#else
    return host;
#endif
}

inline CType_stPack::CType_stPack()
: m_dwMagic(uint32_t()), m_wVersion(uint16_t()), m_wCommand(uint16_t()), m_wDataSize(uint16_t())
{
}

inline CType_stPack::~CType_stPack()
{
}

inline uint32_t& CType_stPack::dwMagic()
{
    return m_dwMagic;
}

inline uint16_t& CType_stPack::wVersion()
{
    return m_wVersion;
}

inline uint16_t& CType_stPack::wCommand()
{
    return m_wCommand;
}

inline const uint16_t& CType_stPack::wDataSize() const
{
    return m_wDataSize;
}

inline size_t CType_stPack::GetNumberOf_acData() const
{
    return m_acData.size();
}

inline uint8_t& CType_stPack::acData(size_t uIndex)
{
    assert(uIndex < GetNumberOf_acData());
    return m_acData[uIndex];
}

inline uint8_t* CType_stPack::acData()
{
    return &m_acData[0];
}

inline void CType_stPack::Assign_acData(const uint8_t acData[], size_t uNumberOfElements)
{
    m_acData.resize(uNumberOfElements);
    m_wDataSize = m_acData.size();
    memcpy(&m_acData[0], acData, uNumberOfElements * sizeof(uint8_t));
}

inline uint8_t& CType_stPack::Add_cData()
{
    m_acData.push_back(uint8_t());
    m_wDataSize = m_acData.size();
    return m_acData.back();
}

inline size_t CType_stPack::SerializeToArray(void* pBuf, size_t uBufSize) const
{
    size_t uSize = 0;
    char* pPos = (char*)pBuf + uSize;

    *(uint32_t*)pPos = htonl(m_dwMagic);
    pPos += sizeof(m_dwMagic);

    *(uint16_t*)pPos = htons(m_wVersion);
    pPos += sizeof(m_wVersion);

    *(uint16_t*)pPos = htons(m_wCommand);
    pPos += sizeof(m_wCommand);

    *(uint16_t*)pPos = htons(m_wDataSize);
    pPos += sizeof(m_wDataSize);

    uSize = GetNumberOf_acData() * sizeof(uint8_t);
    memcpy(pPos, &m_acData[0], uSize);
    pPos += uSize;

    return (size_t)pPos - (size_t)pBuf;
}

inline size_t CType_stPack::ParseFromArray(const void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    const char* pPos = (const char*)pBuf + uSize;

    m_dwMagic = ntohl(*(uint32_t*)pPos);
    pPos += sizeof(m_dwMagic);

    m_wVersion = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wVersion);

    m_wCommand = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wCommand);

    m_wDataSize = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wDataSize);

    m_acData.resize(m_wDataSize);
    uSize = GetNumberOf_acData() * sizeof(uint8_t);
    memcpy(&m_acData[0], pPos, uSize);
    pPos += uSize;

    return (size_t)pPos - (size_t)pBuf;
}

inline CType_stCmdRoomBroadCast::CType_stCmdRoomBroadCast()
: m_wMapIndex(uint16_t()), m_wStageIndex(uint16_t()), m_wLevel(uint16_t())
{
}

inline CType_stCmdRoomBroadCast::~CType_stCmdRoomBroadCast()
{
}

inline uint16_t& CType_stCmdRoomBroadCast::wMapIndex()
{
    return m_wMapIndex;
}

inline uint16_t& CType_stCmdRoomBroadCast::wStageIndex()
{
    return m_wStageIndex;
}

inline uint16_t& CType_stCmdRoomBroadCast::wLevel()
{
    return m_wLevel;
}

inline size_t CType_stCmdRoomBroadCast::SerializeToArray(void* pBuf, size_t uBufSize) const
{
    size_t uSize = 0;
    char* pPos = (char*)pBuf + uSize;

    *(uint16_t*)pPos = htons(m_wMapIndex);
    pPos += sizeof(m_wMapIndex);

    *(uint16_t*)pPos = htons(m_wStageIndex);
    pPos += sizeof(m_wStageIndex);

    *(uint16_t*)pPos = htons(m_wLevel);
    pPos += sizeof(m_wLevel);

    return (size_t)pPos - (size_t)pBuf;
}

inline size_t CType_stCmdRoomBroadCast::ParseFromArray(const void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    const char* pPos = (const char*)pBuf + uSize;

    m_wMapIndex = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wMapIndex);

    m_wStageIndex = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wStageIndex);

    m_wLevel = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wLevel);

    return (size_t)pPos - (size_t)pBuf;
}

};

#endif  //  __PROTOCOL_HPP__
